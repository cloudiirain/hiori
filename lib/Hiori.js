'use strict';

const cheerio = require('cheerio');
const puppeteer = require('puppeteer');
const config = require('./config.json');
const ThreadPost = require('./ThreadPost.js')

/**
 * Hiori is a bot API for the Novel Updates Forum.
 */
module.exports = class Hiori {
  /**
   * @param {string} username
   * @param {string} password
   */
  constructor (username, password, headless=true) {
    this.username = username;
    this.password = password;
    this.config = config;
    this.headless = headless;
  }

  /**
   * @param {function} callback
   */
  async init (callback) {
    this.browser = await puppeteer.launch({headless: this.headless});
    this.page = await this.browser.newPage();
    callback.bind(this)();
  }

  /* Close haori bot instance */
  close () {
    this.browser.close();
  }

  /* Login to NUF. */
  async login () {
    console.log(`visiting: ${this.config.url.login}`);
    const response = await this.page.goto(this.config.url.login);
    // We check for any re-directs here because the user is automatically
    // redirected to the home page if the user is already logged in.
    if (response.url() == this.config.url.login) {
      await this.page.type('#ctrl_pageLogin_login', this.username);
      await this.page.type('#ctrl_pageLogin_password', this.password);
      const [redirect] = await Promise.all([
        this.page.waitForNavigation(),
        this.page.click('#pageLogin input[type="submit"]')
      ]);
      // Throw an error if NUF did not redirect user to home.
      if (redirect.url() != this.config.url.home) {
        throw new Error('Login credentials invalid.');
      }
      return redirect;
    }
  }

  /**
   * Recusively fetch all commands in a whole thread
   * @param {string} initUrl The initial thread page URL.
   * @return {ThreadPost[]}
   */
  async fetchAllThreadPosts (initUrl) {
    console.log(`visiting: ${initUrl}`);
    const response = await this.page.goto(initUrl);
    const html = await this.page.content();
    const $ = await cheerio.load(html);
    const nextUrl_sfx = await $('link[rel=next]').attr('href');
    const msgList = await $('#messageList .message');
    const thisPostList = await msgList.toArray().reduce((prevList, msg) => {
      const post = new ThreadPost($(msg));
    	return prevList.concat(post);
    }, []);
    if (nextUrl_sfx) {
      const nextUrl = this.config.url.home + nextUrl_sfx;
      return thisPostList.concat(await this.fetchAllThreadPosts(nextUrl));
    } else {
      return thisPostList;
    }
  }

  /**
   * Fetch a page in a thread and return a list of commands.
   * @param {int} postId
   * @return [!ThreadCommand]
   */
  async fetchThreadCommandsSince (postId) {
    const postUrl = `${this.config.url.thread_post}${postId}/`;
    const postList = await this.fetchAllThreadPosts(postUrl);
    const cmdList = await postList.reduce((prevList, post) => {
      const cmds = post.getCommands();
      return prevList.concat(cmds);
    }, []);
    return cmdList;
  }

  /**
   * Posts a reply to a thread.
   * @param {int} threadId
   * @param {string} content
   */
  async replyThread (threadId, content) {
    if (!content) {
      throw new RangeError('ReplyThread `content` cannot be empty.');
    }
    const url = `${this.config.url.thread}${threadId}/${this.config.url.thread_reply_sfx}`;
    console.log(`visiting: ${url}`);
    const response = await this.page.goto(url);
    const html = await this.page.content();
    const $ = await cheerio.load(html);
    console.log($('#content h1').text());
    if ($('#content h1').text() != 'Reply to Thread') {
      throw new Error('Unable to load thread reply page');
    }
    await this.page.click('#ThreadReply .redactor_btn_switchmode');
    await this.page.evaluate((content) => {
      document.querySelector('#ThreadReply textarea[name="message"]').value = content;
    }, content);
    const [redirect] = await Promise.all([
      this.page.waitForNavigation(),
      this.page.click('#ThreadReply input[type="submit"]')
    ]);
  }

  /**
   * Wraps supplied text in a bbCodeQuote block.
   * @param {object} command
   * @return {string}
   */
   static bbCodeQuote (command) {
     const value = command.value ? ` ${command.value}` : '';
     const info = `${command.user}, post: ${command.pid}, member: ${command.uid}`;
     return `[QUOTE="${info}"]${command.cmd}${value}[/QUOTE]\n`;
   }

   /**
    * Decode a user string generated by the bot parser.
    * @param {string} text
    * @return {object}
    */
    static decodeUser (code) {
      const preparse = code.split(' ')[0].split('USER:')[1];
      const uid = parseInt(preparse.split('|')[0]);
      const codename = preparse.split('|')[1];
      return {
        'uid': uid,
        'user': codename.replace(/\$_;/g, ' ').replace('@', '')
      }
    }

    /**
     * Strips encoded usernames from text.
     * Example: @USER:12345|@Hello$_;I$_;Am$_;A$_;Tree
     * @param {string} text
     * @return {object}
     */
     static stripUserCode (text) {
       var temp = text.replace(/\$_;/g, ' ').replace(/@USER:\d+\|/g, '')
       return temp;
     }
}
